##{0:0:0:gameMain.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\gameMain.asm

;===============================================================================
; BASIC Loader

*=$0801 ; 10 SYS (2064)

        byte $0E, $08, $0A, $00, $9E, $20, $28, $32
        byte $30, $36, $34, $29, $00, $00, $00

        ; Our code starts at $0810 (2064 decimal)
        ; after the 15 bytes for the BASIC loader

;===============================================================================
; Initialize

        ; Turn off interrupts to stop LIBSCREEN_WAIT failing every so 
        ; often when the kernal interrupt syncs up with the scanline test
        sei

        ; Disable run/stop + restore keys
        lda #$FC 
        sta $0328

        ; Set border and background colors
        ; The last 3 parameters are not used yet
        LIBSCREEN_SETCOLORS Blue, Black, Black, Black, Black

        ; Fill 1000 bytes (40x25) of screen memory 
        LIBSCREEN_SET1000 SCREENRAM, SpaceCharacter

        ; Fill 1000 bytes (40x25) of color memory
        LIBSCREEN_SET1000 COLORRAM, White

        ; Set sprite multicolors
        LIBSPRITE_SETMULTICOLORS_VV MediumGray, DarkGray

        ; Set the memory location of the custom character set
        LIBSCREEN_SETCHARMEMORY 14
        
        ; Initialize the game
        jsr gameAliensInit
        jsr gamePlayerInit

;===============================================================================
; Update

gMLoop
        ; Wait for scanline 255
        LIBSCREEN_WAIT_V 255

        ; Start code timer change border color
        ;inc EXTCOL

        ; Update the library
        jsr libInputUpdate
        jsr libSpritesUpdate

        ; Update the game
        jsr gameAliensUpdate
        jsr gamePlayerUpdate
        jsr gameBulletsUpdate

        ; End code timer reset border color
        ;dec EXTCOL
        
        ; Loop back to the start of the game loop
        jmp gMLoop


##{0:0:0:gameAliens.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\gameAliens.asm

;===============================================================================
; Constants

AliensMax = 7
AliensHorizontalSpeed = 1
AliensFireDelay = 90
AliensRespawnDelay = 255
AliensXMoveDelay = 20
AliensXMoveNumIndices = 100

;===============================================================================
; Variables

aliensActiveArray       dcb AliensMax, 1
aliensActive            byte   0
aliensFrameArray        byte   2,   2,   2,   2,   3,   3,   3
aliensFrame             byte   0
aliensColorArray        byte   Red, Orange, Blue, Yellow, Red, Green, Blue
aliensColor             byte   0
aliensMultiColorArray   byte   True, True, True, True, False, False, False
aliensMultiColor        byte   0
aliensXHighArray        byte   0,   0,   0,   1,   0,   0,   0
aliensXHigh             byte   0
aliensXLowArray         byte  33, 113, 193,  18,  73, 153, 233
aliensXLow              byte   0
aliensYArray            byte  80,  80,  80,  80, 130, 130, 130
aliensY                 byte   0
aliensXLocalArray       byte   0,   0,   0,   0,   0,   0,   0
aliensXLocal            byte   0
aliensYLocalArray       byte   0,   0,   0,   0,   0,   0,   0
aliensYLocal            byte   0
aliensXCharArray        byte   0,   0,   0,   0,   0,   0,   0
aliensXChar             byte   0
aliensXOffsetArray      byte   0,   0,   0,   0,   0,   0,   0
aliensXOffset           byte   0
aliensYOffset           byte   0
aliensYCharArray        byte   0,   0,   0,   0,   0,   0,   0
aliensYChar             byte   0
aliensFireArray         byte   0,  30,  60,  90, 120, 150, 180
aliensFire              byte   0
aliensRespawnArray      byte   0,   0,   0,   0,   0,   0,   0
aliensRespawn           byte   0
aliensTemp              byte   0
aliensCollisionNo       byte   0
aliensSprite            byte   0

aliensXMoveIndexArray   byte   0,   5,  10,  15,  20,  25,  30
aliensXMoveIndex        byte   0


                        ; right
aliensXMoveArray        byte    0,  0,  1,  1,  1,  2,  2,  3,  4,  5
                        byte    6,  7,  8,  9, 10, 11, 12, 13, 14, 15
                        byte   16, 17, 18, 19, 20, 21, 22, 23, 24, 25
                        byte   26, 27, 28, 29, 30, 31, 32, 33, 34, 35
                        byte   36, 37, 38, 39, 39, 40, 40, 40, 41, 41

                        ; left
                        byte   41, 41, 40, 40, 40, 39, 39, 38, 37, 36
                        byte   35, 34, 33, 32, 31, 30, 29, 28, 27, 26
                        byte   25, 24, 23, 22, 21, 20, 19, 18, 17, 16 
                        byte   15, 14, 13, 12, 11, 10,  9,  8,  7,  6
                        byte    5,  4,  3,  2,  2,  1,  1,  1,  0,  0

;==============================================================================
; Macros/Subroutines

gameAliensInit

        ldx #0
        stx aliensSprite
gAILoop
        inc aliensSprite ; x+1
        
        jsr gameAliensGetVariables

        LIBSPRITE_ENABLE_AV             aliensSprite, True
        LIBSPRITE_SETFRAME_AA           aliensSprite, aliensFrame
        LIBSPRITE_SETCOLOR_AA           aliensSprite, aliensColor
        LIBSPRITE_MULTICOLORENABLE_AA   aliensSprite, aliensMultiColor
    
        jsr gameAliensSetVariables
        
        ; loop for each alien
        inx
        cpx #AliensMax
        bne gAILoop
        
        rts

;==============================================================================

gameAliensUpdate

        ldx #0
        stx aliensSprite

gAULoop
        inc aliensSprite ; x+1

        jsr gameAliensGetVariables

        lda aliensActive 
        beq gAUSkipThisAlien

        jsr gameAliensUpdatePosition
        jsr gameAliensUpdateFiring
        jsr gameAliensUpdateCollisions
        
        jmp gAUUpdated

gAUSkipThisAlien
        jsr gameAliensUpdateInactive
gAUUpdated

        jsr gameAliensSetVariables

        ; loop for each alien
        inx
        cpx #AliensMax
        bne gAULoop

        rts

;==============================================================================

gameAliensGetVariables

        lda aliensActiveArray,X
        sta aliensActive
        lda aliensFrameArray,X
        sta aliensFrame
        lda aliensColorArray,X
        sta aliensColor
        lda aliensMultiColorArray,X
        sta aliensMultiColor
        lda aliensXHighArray,X
        sta aliensXHigh
        lda aliensXLowArray,X
        sta aliensXLow
        lda aliensYArray,X
        sta aliensY
        lda aliensXLocalArray,X
        sta aliensXLocal
        lda aliensYLocalArray,X
        sta aliensYLocal
        lda aliensFireArray,X
        sta aliensFire
        lda aliensRespawnArray,X
        sta aliensRespawn
        lda aliensXMoveIndexArray,X
        sta aliensXMoveIndex
        
        stx aliensTemp; save X register as it gets trashed

        rts

;==============================================================================

gameAliensUpdatePosition

        ldy aliensXMoveIndex
        iny
        sty aliensXMoveIndex        
        cpy #AliensXMoveNumIndices
        beq gAUPIResetIndex
        jmp gAUPIDontReset

gAUPIResetIndex
        lda #0
        sta aliensXMoveIndex
        
gAUPIDontReset
        ldy aliensXMoveIndex
        lda aliensXMoveArray,Y
        sta aliensXLocal

        LIBMATH_ADD16BIT_AAVAAA aliensXHigh, aliensXLow, 0, aliensXLocal, aliensXHigh, aliensXLow
        
        LIBSPRITE_SETPOSITION_AAAA aliensSprite, aliensXHigh, aliensXLow, aliensY

        ; update the alien char positions
        LIBSCREEN_PIXELTOCHAR_AAVAVAAAA aliensXHigh, aliensXLow, 12, aliensY, 40, aliensXChar, aliensXOffset, aliensYChar, aliensYOffset

        rts

;==============================================================================

gameAliensUpdateFiring

        lda playerActive ; only fire if the player is alive
        beq gAUFDontfire

        ldy aliensFire
        iny
        sty aliensFire        
        cpy #AliensFireDelay
        beq gAUFFire
        jmp gAUFDontfire
gAUFFire
        
        GAMEBULLETS_FIRE_AAAVV aliensXChar, aliensXOffset, aliensYChar, Yellow, False

        lda #0
        sta aliensFire
gAUFDontfire

        rts

;==============================================================================

gameAliensUpdateCollisions

        GAMEBULLETS_COLLIDED aliensXChar, aliensYChar, True
        
        beq gAUCNocollision
        ; run explosion animation
        LIBSPRITE_PLAYANIM_AVVVV      aliensSprite, 4, 15, 3, False
        LIBSPRITE_SETCOLOR_AV         aliensSprite, Yellow
        LIBSPRITE_MULTICOLORENABLE_AV aliensSprite, True

        lda #False
        sta aliensActive
gAUCNocollision

        rts

;==============================================================================

gameAliensSetVariables

        ldx aliensTemp ; restore X register as it gets trashed

        lda aliensXLocal
        sta aliensXLocalArray,X
        lda aliensYLocal
        sta aliensYLocalArray,X
        lda aliensActive
        sta aliensActiveArray,X
        lda aliensXChar
        sta aliensXCharArray,X
        lda aliensXOffset
        sta aliensXOffsetArray,X
        lda aliensYChar
        sta aliensYCharArray,X
        lda aliensFire
        sta aliensFireArray,X
        lda aliensRespawn
        sta aliensRespawnArray,X
        lda aliensXMoveIndex
        sta aliensXMoveIndexArray,X

        rts

;==============================================================================

gameAliensUpdateInactive

        ldy aliensRespawn
        iny
        sty aliensRespawn
  
        cpy #AliensRespawnDelay
        beq gAUIRespawn
        jmp gAUIDontRespawn

gAUIRespawn

        LIBSPRITE_ENABLE_AV             aliensSprite, true
        LIBSPRITE_SETFRAME_AA           aliensSprite, aliensFrame
        LIBSPRITE_SETCOLOR_AA           aliensSprite, aliensColor
        LIBSPRITE_MULTICOLORENABLE_AA   aliensSprite, aliensMultiColor
      
        lda #0
        sta aliensRespawn
        lda #True
        sta aliensActive

gAUIDontRespawn
        rts
































##{0:0:0:gameBullets.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\gameBullets.asm

; Sprite top left corner to char coordinates:
; int((spr_x-24)/8), int((spr_y-50)/8) 
;===============================================================================
; Constants

BulletsMax = 10
Bullet1stCharacter = 64

;===============================================================================
; Variables

bulletsXHigh    byte 0
bulletsXLow     byte 0     
bulletsY        byte 0
bulletsXCharCurrent byte 0
bulletsXOffsetCurrent byte 0
bulletsYCharCurrent byte 0
bulletsColorCurrent byte 0
bulletsDirCurrent byte 0

bulletsActive   dcb BulletsMax, 0
bulletsXChar    dcb BulletsMax, 0
bulletsYChar    dcb BulletsMax, 0
bulletsXOffset  dcb BulletsMax, 0
bulletsColor    dcb BulletsMax, 0
bulletsDir      dcb BulletsMax, 0
bulletsTemp     byte 0
bulletsXFlag    byte 0

bulletsXCharCol byte 0
bulletsYCharCol byte 0
bulletsDirCol   byte 0

;===============================================================================
; Macros/Subroutines

defm    GAMEBULLETS_FIRE_AAAVV  ; /1 = XChar            (Address)
                                ; /2 = XOffset          (Address)
                                ; /3 = YChar            (Address)
                                ; /4 = Color            (Value)
                                ; /5 = Direction (True-Up, False-Down) (Value)
        ldx #0
@loop
        lda bulletsActive,X
        bne @skip

        ; save the current bullet in the list
        lda #1
        sta bulletsActive,X
        lda /1
        sta bulletsXChar,X
        
        clc
        lda /2 ; get the character offset
        adc #Bullet1stCharacter ; add on the bullet first character
        sta bulletsXOffset,X

        lda /3
        sta bulletsYChar,X
        lda #/4
        sta bulletsColor,X
        lda #/5
        sta bulletsDir,X

        ; found a slot, quit the loop
        jmp @found
@skip
        ; loop for each bullet
        inx
        cpx #BulletsMax
        bne @loop
@found
        endm

;===============================================================================

gameBulletsGet
        lda bulletsXChar,X
        sta bulletsXCharCurrent
        lda bulletsXOffset,X
        sta bulletsXOffsetCurrent
        lda bulletsYChar,X
        sta bulletsYCharCurrent
        lda bulletsColor,X
        sta bulletsColorCurrent
        lda bulletsDir,X
        sta bulletsDirCurrent
        rts

;===============================================================================

gameBulletsUpdate

        ldx #0
buloop
        lda bulletsActive,X
        bne buok
        jmp skipBulletUpdate
buok
        ; get the current bullet from the list
        jsr gameBulletsGet

        LIBSCREEN_SETCHARPOSITION_AA bulletsXCharCurrent, bulletsYCharCurrent
        LIBSCREEN_SETCHAR_V SpaceCharacter
        
        lda bulletsDirCurrent
        beq @down
@up
        ;dec bulletsYCharCurrent
        ;bpl @skip
        ;jmp @dirdone
        ldy bulletsYCharCurrent
        dey
        sty bulletsYCharCurrent
        cpy #0; this leave a row empty at the top for the scores
        bne @skip
        jmp @dirdone

@down
        ldy bulletsYCharCurrent
        iny
        sty bulletsYCharCurrent
        cpy #25
        bne @skip
@dirdone

        lda #0
        sta bulletsActive,X
        jmp skipBulletUpdate        
@skip
        ; set the bullet color
        LIBSCREEN_SETCOLORPOSITION_AA bulletsXCharCurrent, bulletsYCharCurrent
        LIBSCREEN_SETCHAR_A bulletsColorCurrent
        
        ; set the bullet character
        LIBSCREEN_SETCHARPOSITION_AA bulletsXCharCurrent, bulletsYCharCurrent
        LIBSCREEN_SETCHAR_A bulletsXOffsetCurrent

        lda bulletsYCharCurrent
        sta bulletsYChar,X

skipBulletUpdate

        inx
        cpx #BulletsMax
        ;bne @loop       ; loop for each bullet
        beq @finished
        jmp buloop
@finished
        
        rts

;===============================================================================

defm    GAMEBULLETS_COLLIDED    ; /1 = XChar            (Address)
                                ; /2 = YChar            (Address)
                                ; /3 = Direction (True-Up, False-Down) (Value)

        lda /1
        sta bulletsXCharCol
        lda /2
        sta bulletsYCharCol
        lda #/3
        sta bulletsDirCol
        jsr gameBullets_Collided
        endm

gameBullets_Collided

        ldx #0
@loop
        ; skip this bullet if not active
        lda bulletsActive,X
        beq @skip

        ; skip if up/down not equal
        lda bulletsDir,X
        cmp bulletsDirCol
        bne @skip

        ; skip if currentbullet YChar != YChar
        lda bulletsYChar,X
        cmp bulletsYCharCol
        bne @skip

        lda #0
        sta bulletsXFlag

        ; skip if currentbullet XChar != XChar
        ldy bulletsXChar,X
        cpy bulletsXCharCol
        bne @xminus1
        lda #1
        sta bulletsXFlag
        jmp @doneXCheck

@xminus1
        ; skip if currentbullet XChar-1 != XChar
        dey
        cpy bulletsXCharCol
        bne @xplus1
        lda #1
        sta bulletsXFlag
        jmp @doneXCheck
@xplus1
        ; skip if currentbullet XChar+1 != XChar
        iny
        iny
        cpy bulletsXCharCol
        bne @doneXCheck
        lda #1
        sta bulletsXFlag

@doneXCheck
        lda bulletsXFlag
        beq @skip
   
        ; collided
        lda #0
        sta bulletsActive,X ; disable bullet

        ; delete bullet from screen
        lda bulletsXChar,X
        sta bulletsXCharCurrent
        lda bulletsYChar,X
        sta bulletsYCharCurrent
        LIBSCREEN_SETCHARPOSITION_AA bulletsXCharCurrent, bulletsYCharCurrent
        LIBSCREEN_SETCHAR_V SpaceCharacter

        lda #1 ; set as collided
        jmp @collided
@skip
        ; loop for each bullet
        inx
        cpx #BulletsMax
        bne @loop

        ; set as not collided
        lda #0

@collided

        rts



##{0:0:0:gamePlayer.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\gamePlayer.asm

;==============================================================================
; Constants

PlayerFrame             = 1
PlayerHorizontalSpeed   = 2
PlayerVerticalSpeed     = 1
PlayerStartXHigh        = 0
PlayerStartXLow         = 175
PlayerStartY            = 229
PlayerXMinHigh          = 0     ; 0*256 + 24 = 24  minX
PlayerXMinLow           = 24
PlayerXMaxHigh          = 1     ; 1*256 + 64 = 320 maxX
PlayerXMaxLow           = 64
PlayerYMin              = 180
PlayerYMax              = 229 

;===============================================================================
; Variables

playerSprite    byte 0
playerXHigh     byte PlayerStartXHigh
playerXLow      byte PlayerStartXLow
playerY         byte PlayerStartY
playerXChar     byte 0
playerXOffset   byte 0
playerYChar     byte 0
playerYOffset   byte 0
playerActive    byte True

;===============================================================================
; Macros/Subroutines

gamePlayerInit
        
        LIBSPRITE_ENABLE_AV             playerSprite, True
        LIBSPRITE_SETFRAME_AV           playerSprite, PlayerFrame
        LIBSPRITE_SETCOLOR_AV           playerSprite, LightGray
        LIBSPRITE_MULTICOLORENABLE_AV   playerSprite, True
        
        rts

;==============================================================================

gamePlayerReset

        lda #True
        sta playerActive

        LIBSPRITE_ENABLE_AV             playerSprite, True
        LIBSPRITE_SETFRAME_AV           playerSprite, PlayerFrame
        LIBSPRITE_SETCOLOR_AV           playerSprite, LightGray
        
        lda #PlayerStartXHigh
        sta playerXHigh
        lda #PlayerStartXLow
        sta PlayerXLow
        lda #PlayerStartY
        sta PlayerY
        LIBSPRITE_SETPOSITION_AAAA playerSprite, playerXHigh, playerXLow, playerY
        
        rts

;===============================================================================

gamePlayerUpdate

        lda playerActive 
        beq gPUSkip

        jsr gamePlayerUpdatePosition
        jsr gamePlayerUpdateFiring
        jsr gamePlayerUpdateCollisions
gPUSkip

        ; temp reset player if died
        lda playerActive
        bne gPUDontReset
        LIBSPRITE_ISANIMPLAYING_A playerSprite
        bne gPUDontReset
        jsr gamePlayerReset
gPUDontReset

        rts

;==============================================================================

gamePlayerUpdateCollisions

        GAMEBULLETS_COLLIDED playerXChar, playerYChar, False
        beq gPUCNocollision
        lda #False
        sta playerActive
        ; run explosion animation
        LIBSPRITE_SETCOLOR_AV     playerSprite, Yellow
        LIBSPRITE_PLAYANIM_AVVVV  playerSprite, 4, 15, 3, False
                                
gPUCNocollision

        rts

;==============================================================================

gamePlayerUpdateFiring

        ; do fire after the ship has been clamped to position
        ; so that the bullet lines up
        LIBINPUT_GETFIREPRESSED
        bne gPUFNofire
     
        GAMEBULLETS_FIRE_AAAVV playerXChar, playerXOffset, playerYChar, White, 1
gPUFNofire

        rts

;===============================================================================

gamePlayerUpdatePosition

        LIBINPUT_GETHELD GameportLeftMask
        bne gPUPRight
        LIBMATH_SUB16BIT_AAVVAA playerXHigh, PlayerXLow, 0, PlayerHorizontalSpeed, playerXHigh, PlayerXLow
gPUPRight
        LIBINPUT_GETHELD GameportRightMask
        bne gPUPUp
        LIBMATH_ADD16BIT_AAVVAA playerXHigh, PlayerXLow, 0, PlayerHorizontalSpeed, playerXHigh, PlayerXLow
gPUPUp
        LIBINPUT_GETHELD GameportUpMask
        bne gPUPDown
        LIBMATH_SUB8BIT_AVA PlayerY, PlayerVerticalSpeed, PlayerY
gPUPDown
        LIBINPUT_GETHELD GameportDownMask
        bne gPUPEndmove
        LIBMATH_ADD8BIT_AVA PlayerY, PlayerVerticalSpeed, PlayerY        
gPUPEndmove
        
        ; clamp the player x position
        LIBMATH_MIN16BIT_AAVV playerXHigh, playerXLow, PlayerXMaxHigh, PLayerXMaxLow
        LIBMATH_MAX16BIT_AAVV playerXHigh, playerXLow, PlayerXMinHigh, PLayerXMinLow
        
        ; clamp the player y position
        LIBMATH_MIN8BIT_AV playerY, PlayerYMax
        LIBMATH_MAX8BIT_AV playerY, PlayerYMin

        ; set the sprite position
        LIBSPRITE_SETPOSITION_AAAA playerSprite, playerXHigh, PlayerXLow, PlayerY

        ; update the player char positions
        LIBSCREEN_PIXELTOCHAR_AAVAVAAAA playerXHigh, playerXLow, 12, playerY, 40, playerXChar, playerXOffset, playerYChar, playerYOffset

        rts


##{0:0:0:libInput.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\libInput.asm

;===============================================================================
; Constants

 ; use joystick 2, change to CIAPRB for joystick 1
JoystickRegister        = CIAPRA

GameportUpMask          = %00000001
GameportDownMask        = %00000010
GameportLeftMask        = %00000100
GameportRightMask       = %00001000
GameportFireMask        = %00010000
FireDelayMax            = 30

;===============================================================================
; Variables

gameportLastFrame       byte 0
gameportThisFrame       byte 0
gameportDiff            byte 0
fireDelay               byte 0
fireBlip                byte 1 ; reversed logic to match other input

;===============================================================================
; Macros/Subroutines

defm    LIBINPUT_GETHELD ; (buttonMask)

        lda gameportThisFrame
        and #/1
        endm ; test with bne on return

;===============================================================================

defm    LIBINPUT_GETFIREPRESSED
     
        lda #1
        sta fireBlip ; clear Fire flag

        ; is fire held?
        lda gameportThisFrame
        and #GameportFireMask
        bne @notheld

@held
        ; is this 1st frame?
        lda gameportDiff
        and #GameportFireMask
        
        beq @notfirst
        lda #0
        sta fireBlip ; Fire

        ; reset delay
        lda #FireDelayMax
        sta fireDelay        
@notfirst

        ; is the delay zero?
        lda fireDelay
        bne @notheld
        lda #0
        sta fireBlip ; Fire
        ; reset delay
        lda #FireDelayMax
        sta fireDelay   
        
@notheld 
        lda fireBlip
        endm ; test with bne on return

;===============================================================================

libInputUpdate

        lda JoystickRegister
        sta GameportThisFrame

        eor GameportLastFrame
        sta GameportDiff

        
        lda FireDelay
        beq lIUDelayZero
        dec FireDelay
lIUDelayZero

        lda GameportThisFrame
        sta GameportLastFrame

        rts

##{0:0:0:libMath.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\libMath.asm

;===============================================================================
; Macros/Subroutines

defm    LIBMATH_ABS_AA  ; /1 = Number (Address)
                        ; /2 = Result (Address)
        lda /1
        bpl @positive
        eor #$FF        ; invert the bits
        sta /2
        inc /2          ; add 1 to give the two's compliment
        jmp @done
@positive
        sta /2
@done
        endm

;==============================================================================

defm    LIBMATH_ADD8BIT_AAA
                ; /1 = 1st Number (Address)
                ; /2 = 2nd Number (Address)
                ; /3 = Sum (Address)
        clc     ; Clear carry before add
        lda /1  ; Get first number
        adc /2 ; Add to second number
        sta /3  ; Store in sum
        endm

;==============================================================================

defm    LIBMATH_ADD8BIT_AVA
                ; /1 = 1st Number (Address)
                ; /2 = 2nd Number (Value)
                ; /3 = Sum (Address)
        clc     ; Clear carry before add
        lda /1  ; Get first number
        adc #/2 ; Add to second number
        sta /3  ; Store in sum
        endm

;==============================================================================

defm    LIBMATH_ADD16BIT_AAVAAA
                ; /1 = 1st Number High Byte (Address)
                ; /2 = 1st Number Low Byte (Address)
                ; /3 = 2nd Number High Byte (Value)
                ; /4 = 2nd Number Low Byte (Address)
                ; /5 = Sum High Byte (Address)
                ; /6 = Sum Low Byte (Address)
        clc     ; Clear carry before first add
        lda /2  ; Get LSB of first number
        adc /4  ; Add LSB of second number
        sta /6  ; Store in LSB of sum
        lda /1  ; Get MSB of first number
        adc #/3 ; Add carry and MSB of NUM2
        sta /5  ; Store sum in MSB of sum
        endm

;==============================================================================

defm    LIBMATH_ADD16BIT_AAVVAA
                ; /1 = 1st Number High Byte (Address)
                ; /2 = 1st Number Low Byte (Address)
                ; /3 = 2nd Number High Byte (Value)
                ; /4 = 2nd Number Low Byte (Value)
                ; /5 = Sum High Byte (Address)
                ; /6 = Sum Low Byte (Address)
        clc     ; Clear carry before first add
        lda /2  ; Get LSB of first number
        adc #/4 ; Add LSB of second number
        sta /6  ; Store in LSB of sum
        lda /1  ; Get MSB of first number
        adc #/3 ; Add carry and MSB of NUM2
        sta /5  ; Store sum in MSB of sum
        endm

;==============================================================================

defm    LIBMATH_MIN8BIT_AV      ; /1 = Number 1 (Address)
                                ; /2 = Number 2 (Value)
        
        lda #/2                 ; load Number 2
        cmp /1                  ; compare with Number 1
        bcs @skip               ; if Number 2 >= Number 1 then skip
        sta /1                  ; else replace Number1 with Number2
@skip
        endm

;==============================================================================

defm    LIBMATH_MAX8BIT_AV      ; /1 = Number 1 (Address)
                                ; /2 = Number 2 (Value)
        
        lda #/2                 ; load Number 2
        cmp /1                  ; compare with Number 1
        bcc @skip               ; if Number 2 < Number 1 then skip
        sta /1                  ; else replace Number1 with Number2
@skip
        endm

;==============================================================================

defm    LIBMATH_MIN16BIT_AAVV   ; /1 = Number 1 High (Address)
                                ; /2 = Number 1 Low (Address)
                                ; /3 = Number 2 High (Value)
                                ; /4 = Number 2 Low (Value)
        
        ; high byte
        lda /1                  ; load Number 1
        cmp #/3                 ; compare with Number 2
        bmi @skip               ; if Number 1 < Number 2 then skip
        lda #/3
        sta /1                  ; else replace Number1 with Number2

        ; low byte
        lda #/4                 ; load Number 2
        cmp /2                  ; compare with Number 1
        bcs @skip               ; if Number 2 >= Number 1 then skip
        sta /2                  ; else replace Number1 with Number2
@skip
        endm

;==============================================================================

defm    LIBMATH_MAX16BIT_AAVV   ; /1 = Number 1 High (Address)
                                ; /2 = Number 1 Low (Address)
                                ; /3 = Number 2 High (Value)
                                ; /4 = Number 2 Low (Value)
        
        ; high byte
        lda #/3                 ; load Number 2
        cmp /1                  ; compare with Number 1
        bcc @skip               ; if Number 2 < Number 1 then skip
        sta /1                  ; else replace Number1 with Number2

        ; low byte
        lda #/4                 ; load Number 2
        cmp /2                  ; compare with Number 1
        bcc @skip               ; if Number 2 < Number 1 then skip
        sta /2                  ; else replace Number1 with Number2

@skip
        endm

;==============================================================================

defm    LIBMATH_SUB8BIT_AAA
                ; /1 = 1st Number (Address)
                ; /2 = 2nd Number (Address)
                ; /3 = Sum (Address)
        sec     ; sec is the same as clear borrow
        lda /1  ; Get first number
        sbc /2  ; Subtract second number
        sta /3  ; Store in sum
        endm

;==============================================================================

defm    LIBMATH_SUB8BIT_AVA
                ; /1 = 1st Number (Address)
                ; /2 = 2nd Number (Value)
                ; /3 = Sum (Address)
        sec     ; sec is the same as clear borrow
        lda /1  ; Get first number
        sbc #/2 ; Subtract second number
        sta /3  ; Store in sum
        endm

;==============================================================================

defm    LIBMATH_SUB16BIT_AAVAAA
                ; /1 = 1st Number High Byte (Address)
                ; /2 = 1st Number Low Byte (Address)
                ; /3 = 2nd Number High Byte (Value)
                ; /4 = 2nd Number Low Byte (Address)
                ; /5 = Sum High Byte (Address)
                ; /6 = Sum Low Byte (Address)
        sec     ; sec is the same as clear borrow
        lda /2  ; Get LSB of first number
        sbc /4 ; Subtract LSB of second number
        sta /6  ; Store in LSB of sum
        lda /1  ; Get MSB of first number
        sbc #/3 ; Subtract borrow and MSB of NUM2
        sta /5  ; Store sum in MSB of sum
        endm

;==============================================================================

defm    LIBMATH_SUB16BIT_AAVVAA
                ; /1 = 1st Number High Byte (Address)
                ; /2 = 1st Number Low Byte (Address)
                ; /3 = 2nd Number High Byte (Value)
                ; /4 = 2nd Number Low Byte (Value)
                ; /5 = Sum High Byte (Address)
                ; /6 = Sum Low Byte (Address)
        sec     ; sec is the same as clear borrow
        lda /2  ; Get LSB of first number
        sbc #/4 ; Subtract LSB of second number
        sta /6  ; Store in LSB of sum
        lda /1  ; Get MSB of first number
        sbc #/3 ; Subtract borrow and MSB of NUM2
        sta /5  ; Store sum in MSB of sum
        endm

##{0:0:0:libScreen.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\libScreen.asm

;===============================================================================
; Constants

Black           = 0
White           = 1
Red             = 2
Cyan            = 3 
Purple          = 4
Green           = 5
Blue            = 6
Yellow          = 7
Orange          = 8
Brown           = 9
LightRed        = 10
DarkGray        = 11
MediumGray      = 12
LightGreen      = 13
LightBlue       = 14
LightGray       = 15
SpaceCharacter  = 32

False           = 0
True            = 1

;===============================================================================
; Variables

Operator Calc

ScreenRAMRowStartLow ;  SCREENRAM + 40*0, 40*1, 40*2 ... 40*24
        byte <SCREENRAM,     <SCREENRAM+40,  <SCREENRAM+80
        byte <SCREENRAM+120, <SCREENRAM+160, <SCREENRAM+200
        byte <SCREENRAM+240, <SCREENRAM+280, <SCREENRAM+320
        byte <SCREENRAM+360, <SCREENRAM+400, <SCREENRAM+440
        byte <SCREENRAM+480, <SCREENRAM+520, <SCREENRAM+560
        byte <SCREENRAM+600, <SCREENRAM+640, <SCREENRAM+680
        byte <SCREENRAM+720, <SCREENRAM+760, <SCREENRAM+800
        byte <SCREENRAM+840, <SCREENRAM+880, <SCREENRAM+920
        byte <SCREENRAM+960

ScreenRAMRowStartHigh ;  SCREENRAM + 40*0, 40*1, 40*2 ... 40*24
        byte >SCREENRAM,     >SCREENRAM+40,  >SCREENRAM+80
        byte >SCREENRAM+120, >SCREENRAM+160, >SCREENRAM+200
        byte >SCREENRAM+240, >SCREENRAM+280, >SCREENRAM+320
        byte >SCREENRAM+360, >SCREENRAM+400, >SCREENRAM+440
        byte >SCREENRAM+480, >SCREENRAM+520, >SCREENRAM+560
        byte >SCREENRAM+600, >SCREENRAM+640, >SCREENRAM+680
        byte >SCREENRAM+720, >SCREENRAM+760, >SCREENRAM+800
        byte >SCREENRAM+840, >SCREENRAM+880, >SCREENRAM+920
        byte >SCREENRAM+960

ColorRAMRowStartLow ;  COLORRAM + 40*0, 40*1, 40*2 ... 40*24
        byte <COLORRAM,     <COLORRAM+40,  <COLORRAM+80
        byte <COLORRAM+120, <COLORRAM+160, <COLORRAM+200
        byte <COLORRAM+240, <COLORRAM+280, <COLORRAM+320
        byte <COLORRAM+360, <COLORRAM+400, <COLORRAM+440
        byte <COLORRAM+480, <COLORRAM+520, <COLORRAM+560
        byte <COLORRAM+600, <COLORRAM+640, <COLORRAM+680
        byte <COLORRAM+720, <COLORRAM+760, <COLORRAM+800
        byte <COLORRAM+840, <COLORRAM+880, <COLORRAM+920
        byte <COLORRAM+960

ColorRAMRowStartHigh ;  COLORRAM + 40*0, 40*1, 40*2 ... 40*24
        byte >COLORRAM,     >COLORRAM+40,  >COLORRAM+80
        byte >COLORRAM+120, >COLORRAM+160, >COLORRAM+200
        byte >COLORRAM+240, >COLORRAM+280, >COLORRAM+320
        byte >COLORRAM+360, >COLORRAM+400, >COLORRAM+440
        byte >COLORRAM+480, >COLORRAM+520, >COLORRAM+560
        byte >COLORRAM+600, >COLORRAM+640, >COLORRAM+680
        byte >COLORRAM+720, >COLORRAM+760, >COLORRAM+800
        byte >COLORRAM+840, >COLORRAM+880, >COLORRAM+920
        byte >COLORRAM+960

Operator HiLo

screenColumn      byte 0
screenScrollXValue byte 0

;===============================================================================
; Macros/Subroutines

defm    LIBSCREEN_DEBUG8BIT_VVA
                        ; /1 = X Position Absolute
                        ; /2 = Y Position Absolute
                        ; /3 = 1st Number Low Byte Pointer
        
        lda #White
        sta $0286       ; set text color
        lda #$20        ; space
        jsr $ffd2       ; print 4 spaces
        jsr $ffd2
        jsr $ffd2
        jsr $ffd2
        ;jsr $E566      ; reset cursor
        ldx #/2         ; Select row 
        ldy #/1         ; Select column 
        jsr $E50C       ; Set cursor 

        lda #0
        ldx /3
        jsr $BDCD       ; print number
        endm

;===============================================================================

defm    LIBSCREEN_DEBUG16BIT_VVAA
                        ; /1 = X Position Absolute
                        ; /2 = Y Position Absolute
                        ; /3 = 1st Number High Byte Pointer
                        ; /4 = 1st Number Low Byte Pointer
        
        lda #White
        sta $0286       ; set text color
        lda #$20        ; space
        jsr $ffd2       ; print 4 spaces
        jsr $ffd2
        jsr $ffd2
        jsr $ffd2
        ;jsr $E566      ; reset cursor
        ldx #/2         ; Select row 
        ldy #/1         ; Select column 
        jsr $E50C       ; Set cursor 

        lda /3
        ldx /4
        jsr $BDCD       ; print number
        endm

;==============================================================================

defm    LIBSCREEN_DRAWTEXT_AAAV ; /1 = X Position 0-39 (Address)
                                ; /2 = Y Position 0-24 (Address)
                                ; /3 = 0 terminated string (Address)
                                ; /4 = Text Color (Value)

        ldy /2 ; load y position as index into list
        
        lda ScreenRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ScreenRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        ldx #0
@loop   lda /3,X
        cmp #0
        beq @done
        sta (ZeroPageLow),Y
        inx
        iny
        jmp @loop
@done


        ldy /2 ; load y position as index into list
        
        lda ColorRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ColorRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        ldx #0
@loop2  lda /3,X
        cmp #0
        beq @done2
        lda #/4
        sta (ZeroPageLow),Y
        inx
        iny
        jmp @loop2
@done2

        endm

;===============================================================================

defm    LIBSCREEN_DRAWDECIMAL_AAAV ; /1 = X Position 0-39 (Address)
                                ; /2 = Y Position 0-24 (Address)
                                ; /3 = decimal number 2 nybbles (Address)
                                ; /4 = Text Color (Value)

        ldy /2 ; load y position as index into list
        
        lda ScreenRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ScreenRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        ; get high nybble
        lda /3
        and #$F0
        
        ; convert to ascii
        lsr
        lsr
        lsr
        lsr
        ora #$30

        sta (ZeroPageLow),Y

        ; move along to next screen position
        iny 

        ; get low nybble
        lda /3
        and #$0F

        ; convert to ascii
        ora #$30  

        sta (ZeroPageLow),Y
    

        ; now set the colors
        ldy /2 ; load y position as index into list
        
        lda ColorRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ColorRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        lda #/4
        sta (ZeroPageLow),Y

        ; move along to next screen position
        iny 
        
        sta (ZeroPageLow),Y

        endm

;==============================================================================

defm    LIBSCREEN_GETCHAR  ; /1 = Return character code (Address)
        lda (ZeroPageLow),Y
        sta /1
        endm

;===============================================================================

defm    LIBSCREEN_PIXELTOCHAR_AAVAVAAAA
                                ; /1 = XHighPixels      (Address)
                                ; /2 = XLowPixels       (Address)
                                ; /3 = XAdjust          (Value)
                                ; /4 = YPixels          (Address)
                                ; /5 = YAdjust          (Value)
                                ; /6 = XChar            (Address)
                                ; /7 = XOffset          (Address)
                                ; /8 = YChar            (Address)
                                ; /9 = YOffset          (Address)
                                

        lda /1
        sta ZeroPageParam1
        lda /2
        sta ZeroPageParam2
        lda #/3
        sta ZeroPageParam3
        lda /4
        sta ZeroPageParam4
        lda #/5
        sta ZeroPageParam5
        
        jsr libScreen_PixelToChar

        lda ZeroPageParam6
        sta /6
        lda ZeroPageParam7
        sta /7
        lda ZeroPageParam8
        sta /8
        lda ZeroPageParam9
        sta /9

        endm

libScreen_PixelToChar

        ; subtract XAdjust pixels from XPixels as left of a sprite is first visible at x = 24
        LIBMATH_SUB16BIT_AAVAAA ZeroPageParam1, ZeroPageParam2, 0, ZeroPageParam3, ZeroPageParam6, ZeroPageParam7

        lda ZeroPageParam6
        sta ZeroPageTemp

        ; divide by 8 to get character X
        lda ZeroPageParam7
        lsr A ; divide by 2
        lsr A ; and again = /4
        lsr A ; and again = /8
        sta ZeroPageParam6

        ; AND 7 to get pixel offset X
        lda ZeroPageParam7
        and #7
        sta ZeroPageParam7

        ; Adjust for XHigh
        lda ZeroPageTemp
        beq @nothigh
        LIBMATH_ADD8BIT_AVA ZeroPageParam6, 32, ZeroPageParam6 ; shift across 32 chars

@nothigh
        ; subtract YAdjust pixels from YPixels as top of a sprite is first visible at y = 50
        LIBMATH_SUB8BIT_AAA ZeroPageParam4, ZeroPageParam5, ZeroPageParam9


        ; divide by 8 to get character Y
        lda ZeroPageParam9
        lsr A ; divide by 2
        lsr A ; and again = /4
        lsr A ; and again = /8
        sta ZeroPageParam8

        ; AND 7 to get pixel offset Y
        lda ZeroPageParam9
        and #7
        sta ZeroPageParam9

        rts

;==============================================================================

defm    LIBSCREEN_SCROLLXLEFT_A          ; /1 = update subroutine (Address)

        dec screenScrollXValue
        lda screenScrollXValue
        and #%00000111
        sta screenScrollXValue

        lda SCROLX
        and #%11111000
        ora screenScrollXValue
        sta SCROLX

        lda screenScrollXValue
        cmp #7
        bne @finished

        ; move to next column
        inc screenColumn
        jsr /1 ; call the passed in function to update the screen rows
@finished

        endm

;==============================================================================

defm    LIBSCREEN_SCROLLXRIGHT_A         ; /1 = update subroutine (Address)

        inc screenScrollXValue
        lda screenScrollXValue
        and #%00000111
        sta screenScrollXValue

        lda SCROLX
        and #%11111000
        ora screenScrollXValue
        sta SCROLX

        lda screenScrollXValue
        cmp #0
        bne @finished

        ; move to previous column
        dec screenColumn
        jsr /1 ; call the passed in function to update the screen rows
@finished

        endm

;==============================================================================

defm    LIBSCREEN_SCROLLXRESET_A         ; /1 = update subroutine (Address)

        lda #0
        sta screenColumn
        sta screenScrollXValue

        lda SCROLX
        and #%11111000
        ora screenScrollXValue
        sta SCROLX

        jsr /1 ; call the passed in function to update the screen rows

        endm

;==============================================================================

defm    LIBSCREEN_SETSCROLLXVALUE_A     ; /1 = ScrollX value (Address)

        lda SCROLX
        and #%11111000
        ora /1
        sta SCROLX

        endm

;==============================================================================

defm    LIBSCREEN_SETSCROLLXVALUE_V     ; /1 = ScrollX value (Value)

        lda SCROLX
        and #%11111000
        ora #/1
        sta SCROLX

        endm

;==============================================================================

; Sets 1000 bytes of memory from start address with a value
defm    LIBSCREEN_SET1000       ; /1 = Start  (Address)
                                ; /2 = Number (Value)

        lda #/2                 ; Get number to set
        ldx #250                ; Set loop value
@loop   dex                     ; Step -1
        sta /1,x                ; Set start + x
        sta /1+250,x            ; Set start + 250 + x
        sta /1+500,x            ; Set start + 500 + x
        sta /1+750,x            ; Set start + 750 + x
        bne @loop               ; If x<>0 loop

        endm

;==============================================================================

defm    LIBSCREEN_SET38COLUMNMODE

        lda SCROLX
        and #%11110111 ; clear bit 3
        sta SCROLX

        endm

;==============================================================================

defm    LIBSCREEN_SET40COLUMNMODE

        lda SCROLX
        ora #%00001000 ; set bit 3
        sta SCROLX

        endm

;==============================================================================

defm    LIBSCREEN_SETCHARMEMORY  ; /1 = Character Memory Slot (Value)
        ; point vic (lower 4 bits of $d018)to new character data
        lda VMCSB
        and #%11110000 ; keep higher 4 bits
        ; p208 M Jong book
        ora #/1;$0E ; maps to  $3800 memory address
        sta VMCSB
        endm

;==============================================================================

defm    LIBSCREEN_SETCHAR_V  ; /1 = Character Code (Value)
        lda #/1
        sta (ZeroPageLow),Y
        endm

;==============================================================================

defm    LIBSCREEN_SETCHAR_A  ; /1 = Character Code (Address)
        lda /1
        sta (ZeroPageLow),Y
        endm

;==============================================================================

defm    LIBSCREEN_SETCHARPOSITION_AA    ; /1 = X Position 0-39 (Address)
                                ; /2 = Y Position 0-24 (Address)
        
        ldy /2 ; load y position as index into list
        
        lda ScreenRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ScreenRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        endm

;==============================================================================

defm    LIBSCREEN_SETCOLORPOSITION_AA   ; /1 = X Position 0-39 (Address)
                                ; /2 = Y Position 0-24 (Address)
                               
        ldy /2 ; load y position as index into list
        
        lda ColorRAMRowStartLow,Y ; load low address byte
        sta ZeroPageLow

        lda ColorRAMRowStartHigh,Y ; load high address byte
        sta ZeroPageHigh

        ldy /1 ; load x position into Y register

        endm

;===============================================================================

; Sets the border and background colors
defm    LIBSCREEN_SETCOLORS     ; /1 = Border Color       (Value)
                                ; /2 = Background Color 0 (Value)
                                ; /3 = Background Color 1 (Value)
                                ; /4 = Background Color 2 (Value)
                                ; /5 = Background Color 3 (Value)
                                
        lda #/1                 ; Color0 -> A
        sta EXTCOL              ; A -> EXTCOL
        lda #/2                 ; Color1 -> A
        sta BGCOL0              ; A -> BGCOL0
        lda #/3                 ; Color2 -> A
        sta BGCOL1              ; A -> BGCOL1
        lda #/4                 ; Color3 -> A
        sta BGCOL2              ; A -> BGCOL2
        lda #/5                 ; Color4 -> A
        sta BGCOL3              ; A -> BGCOL3

        endm

;==============================================================================

defm    LIBSCREEN_SETMULTICOLORMODE

        lda SCROLX
        ora #%00010000 ; set bit 5
        sta SCROLX

        endm

;===============================================================================

; Waits for a given scanline 
defm    LIBSCREEN_WAIT_V        ; /1 = Scanline (Value)

@loop   lda #/1                 ; Scanline -> A
        cmp RASTER              ; Compare A to current raster line
        bne @loop               ; Loop if raster line not reached 255

        endm



##{0:0:0:libSprite.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\libSprite.asm

;===============================================================================
; Constants

SpriteAnimsMax = 8

;===============================================================================
; Variables

spriteAnimsActive       dcb SpriteAnimsMax, 0
spriteAnimsStartFrame   dcb SpriteAnimsMax, 0
spriteAnimsFrame        dcb SpriteAnimsMax, 0
spriteAnimsEndFrame     dcb SpriteAnimsMax, 0
spriteAnimsStopFrame    dcb SpriteAnimsMax, 0
spriteAnimsSpeed        dcb SpriteAnimsMax, 0
spriteAnimsDelay        dcb SpriteAnimsMax, 0
spriteAnimsLoop         dcb SpriteAnimsMax, 0

spriteAnimsCurrent       byte 0
spriteAnimsFrameCurrent  byte 0
spriteAnimsEndFrameCurrent  byte 0

spriteNumberMask  byte %00000001, %00000010, %00000100, %00001000,                                     %00010000, %00100000, %01000000, %10000000

;===============================================================================
; Macros/Subroutines


defm    LIBSPRITE_DIDCOLLIDEWITHSPRITE_A  ; /1 = Sprite Number (Address)
       
        ldy /1
        lda SpriteNumberMask,y
        and SPSPCL
        
        endm

;===============================================================================

defm    LIBSPRITE_ENABLE_AV                ; /1 = Sprite Number (Address)
                                           ; /2 = Enable/Disable (Value)
        ldy /1
        lda spriteNumberMask,y
        
        ldy #/2
        beq @disable
@enable
        ora SPENA ; merge with the current SpriteEnable register
        sta SPENA ; set the new value into the SpriteEnable register
        jmp @done 
@disable
        eor #$FF ; get mask compliment
        and SPENA
        sta SPENA
@done
        endm

;==============================================================================

defm    LIBSPRITE_ISANIMPLAYING_A      ; /1 = Sprite Number    (Address)

        ldy /1
        lda spriteAnimsActive,y

        endm

;===============================================================================

defm    LIBSPRITE_MULTICOLORENABLE_AA    ; /1 = Sprite Number (Address)
                                         ; /2 = Enable/Disable (Address)
        ldy /1
        lda spriteNumberMask,y
        
        ldy /2
        beq @disable
@enable
        ora SPMC
        sta SPMC
        jmp @done 
@disable
        eor #$FF ; get mask compliment
        and SPMC
        sta SPMC
@done
        endm

;===============================================================================

defm    LIBSPRITE_MULTICOLORENABLE_AV   ; /1 = Sprite Number (Address)
                                        ; /2 = Enable/Disable (Value)
        ldy /1
        lda spriteNumberMask,y
        
        ldy #/2
        beq @disable
@enable
        ora SPMC
        sta SPMC
        jmp @done 
@disable
        eor #$FF ; get mask compliment
        and SPMC
        sta SPMC
@done
        endm

;==============================================================================

defm    LIBSPRITE_PLAYANIM_AVVVV        ; /1 = Sprite Number    (Address)
                                        ; /2 = StartFrame       (Value)
                                        ; /3 = EndFrame         (Value)
                                        ; /4 = Speed            (Value)
                                        ; /5 = Loop True/False  (Value)

        ldy /1

        lda #True
        sta spriteAnimsActive,y
        lda #/2
        sta spriteAnimsStartFrame,y
        sta spriteAnimsFrame,y
        lda #/3
        sta spriteAnimsEndFrame,y
        lda #/4
        sta spriteAnimsSpeed,y
        sta spriteAnimsDelay,y
        lda #/5
        sta spriteAnimsLoop,y

        endm

;===============================================================================

defm    LIBSPRITE_SETCOLOR_AV           ; /1 = Sprite Number    (Address)
                                        ; /2 = Color            (Value)
        ldy /1
        lda #/2
        sta SP0COL,y
        endm

;===============================================================================

defm    LIBSPRITE_SETCOLOR_AA           ; /1 = Sprite Number    (Address)
                                        ; /2 = Color            (Address)
        ldy /1
        lda /2
        sta SP0COL,y
        endm

;==============================================================================

defm    LIBSPRITE_SETFRAME_AA           ; /1 = Sprite Number    (Address)
                                        ; /2 = Anim Index       (Address)
        ldy /1
        
        clc     ; Clear carry before add
        lda /2  ; Get first number
        adc #SPRITERAM ; Add
         
        sta SPRITE0,y
        endm

;===============================================================================

defm    LIBSPRITE_SETFRAME_AV           ; /1 = Sprite Number    (Address)
                                        ; /2 = Anim Index       (Value)
        ldy /1
        
        clc     ; Clear carry before add
        lda #/2  ; Get first number
        adc #SPRITERAM ; Add
         
        sta SPRITE0,y
        endm

;===============================================================================

defm    LIBSPRITE_SETMULTICOLORS_VV     ; /1 = Color 1          (Value)
                                        ; /2 = Color 2          (Value)
        lda #/1
        sta SPMC0
        lda #/2
        sta SPMC1
        endm

;===============================================================================

defm    LIBSPRITE_SETPOSITION_AAAA      ; /1 = Sprite Number    (Address)
                                        ; /2 = XPos High Byte   (Address)
                                        ; /3 = XPos Low Byte    (Address)
                                        ; /4 = YPos             (Address)

        lda /1                  ; get sprite number
        asl                     ; *2 as registers laid out 2 apart
        tay                     ; copy accumulator to y register

        lda /3                  ; get XPos Low Byte
        sta SP0X,y              ; set the XPos sprite register
        lda /4                  ; get YPos
        sta SP0Y,y              ; set the YPos sprite register
        
        ldy /1
        lda spriteNumberMask,y  ; get sprite mask
        
        eor #$FF                ; get compliment
        and MSIGX               ; clear the bit
        sta MSIGX               ; and store

        ldy /2                  ; get XPos High Byte
        beq @end                ; skip if XPos High Byte is zero
        ldy /1
        lda spriteNumberMask,y  ; get sprite mask
        
        ora MSIGX               ; set the bit
        sta MSIGX               ; and store
@end
        endm

;===============================================================================

defm    LIBSPRITE_SETPOSITION_VAAA      ; /1 = Sprite Number    (Value)
                                        ; /2 = XPos High Byte   (Address)
                                        ; /3 = XPos Low Byte    (Address)
                                        ; /4 = YPos             (Address)

        ldy #/1*2               ; *2 as registers laid out 2 apart
        lda /3                  ; get XPos Low Byte
        sta SP0X,y              ; set the XPos sprite register
        lda /4                  ; get YPos
        sta SP0Y,y              ; set the YPos sprite register
        
        lda #1<<#/1             ; shift 1 into sprite bit position
        eor #$FF                ; get compliment
        and MSIGX               ; clear the bit
        sta MSIGX               ; and store

        ldy /2                  ; get XPos High Byte
        beq @end                ; skip if XPos High Byte is zero
        lda #1<<#/1             ; shift 1 into sprite bit position
        ora MSIGX               ; set the bit
        sta MSIGX               ; and store
@end
        endm


;===============================================================================

defm    LIBSPRITE_SETPRIORITY_AV ; /1 = Sprite Number           (Address)
                                 ; /2 = True = Back, False = Front (Value)
        ldy /1
        lda spriteNumberMask,y
        
        ldy #/2
        beq @disable
@enable
        ora SPBGPR ; merge with the current SPBGPR register
        sta SPBGPR ; set the new value into the SPBGPR register
        jmp @done 
@disable
        eor #$FF ; get mask compliment
        and SPBGPR
        sta SPBGPR
@done
        endm

;==============================================================================

defm    LIBSPRITE_STOPANIM_A            ; /1 = Sprite Number    (Address)

        ldy /1
        lda #0
        sta spriteAnimsActive,y

        endm

;==============================================================================

libSpritesUpdate

        ldx #0
lSoULoop
        ; skip this sprite anim if not active
        lda spriteAnimsActive,X
        bne lSoUActive
        jmp lSoUSkip
lSoUActive

        stx spriteAnimsCurrent
        lda spriteAnimsFrame,X
        sta spriteAnimsFrameCurrent

        lda spriteAnimsEndFrame,X
        sta spriteAnimsEndFrameCurrent
        
        LIBSPRITE_SETFRAME_AA spriteAnimsCurrent, spriteAnimsFrameCurrent

        dec spriteAnimsDelay,X
        bne lSoUSkip

        ; reset the delay
        lda spriteAnimsSpeed,X
        sta spriteAnimsDelay,X

        ; change the frame
        inc spriteAnimsFrame,X
        
        ; check if reached the end frame
        lda spriteAnimsEndFrameCurrent
        cmp spriteAnimsFrame,X
        bcs lSoUSkip

        ; check if looping
        lda spriteAnimsLoop,X
        beq lSoUDestroy

        ; reset the frame
        lda spriteAnimsStartFrame,X
        sta spriteAnimsFrame,X
        jmp lSoUSkip

lSoUDestroy
        ; turn off
        lda #False
        sta spriteAnimsActive,X
        LIBSPRITE_ENABLE_AV spriteAnimsCurrent, False

lSoUSkip
        ; loop for each sprite anim
        inx
        cpx #SpriteAnimsMax
        ;bne lSUloop
        beq lSoUFinished
        jmp lSoUloop
lSoUFinished

        rts

##{0:0:0:gameMemory.prg}C:\GAME_DEV\RETROGAMEDEV.COM\RetroGameDevC64_BookFiles\Chapters\c64_santa_cap9_1\gameMemory.asm

;===============================================================================
; $00-$FF  PAGE ZERO (256 bytes)
 
                ; $00-$01   Reserved for IO
ZeroPageTemp    = $02
                ; $03-$8F   Reserved for BASIC
                ; using $73-$8A CHRGET as BASIC not used for our game
ZeroPageParam1  = $73
ZeroPageParam2  = $74
ZeroPageParam3  = $75
ZeroPageParam4  = $76
ZeroPageParam5  = $77
ZeroPageParam6  = $78
ZeroPageParam7  = $79
ZeroPageParam8  = $7A
ZeroPageParam9  = $7B
                ; $90-$FA   Reserved for Kernal
ZeroPageLow     = $FB
ZeroPageHigh    = $FC
ZeroPageLow2    = $FD
ZeroPageHigh2   = $FE
                ; $FF       Reserved for Kernal

;===============================================================================
; $0100-$01FF  STACK (256 bytes)


;===============================================================================
; $0200-$9FFF  RAM (40K)

SCREENRAM       = $0400
SPRITE0         = $07F8

; $0801
; Game code is placed here by using the *=$0801 directive 
; in gameMain.asm 

; 192 decimal * 64(sprite size) = 12288(hex $3000)
SPRITERAM       = 192
* = $3000
        incbin sprites.bin

* = $3800
        incbin characters.bin

;===============================================================================
; $A000-$BFFF  BASIC ROM (8K)


;===============================================================================
; $C000-$CFFF  RAM (4K)


;===============================================================================
; $D000-$DFFF  IO (4K)

; These are some of the C64 registers that are mapped into
; IO memory space
; Names taken from 'Mapping the Commodore 64' book

SP0X            = $D000
SP0Y            = $D001
MSIGX           = $D010
RASTER          = $D012
SPENA           = $D015
SCROLX          = $D016
VMCSB           = $D018
SPBGPR          = $D01B
SPMC            = $D01C
SPSPCL          = $D01E
EXTCOL          = $D020
BGCOL0          = $D021
BGCOL1          = $D022
BGCOL2          = $D023
BGCOL3          = $D024
SPMC0           = $D025
SPMC1           = $D026
SP0COL          = $D027
FRELO1          = $D400 ;(54272)
FREHI1          = $D401 ;(54273)
PWLO1           = $D402 ;(54274)
PWHI1           = $D403 ;(54275)
VCREG1          = $D404 ;(54276)
ATDCY1          = $D405 ;(54277)
SUREL1          = $D406 ;(54278)
FRELO2          = $D407 ;(54279)
FREHI2          = $D408 ;(54280)
PWLO2           = $D409 ;(54281)
PWHI2           = $D40A ;(54282)
VCREG2          = $D40B ;(54283)
ATDCY2          = $D40C ;(54284)
SUREL2          = $D40D ;(54285)
FRELO3          = $D40E ;(54286)
FREHI3          = $D40F ;(54287)
PWLO3           = $D410 ;(54288)
PWHI3           = $D411 ;(54289)
VCREG3          = $D412 ;(54290)
ATDCY3          = $D413 ;(54291)
SUREL3          = $D414 ;(54292)
SIGVOL          = $D418 ;(54296)      
COLORRAM        = $D800
CIAPRA          = $DC00
CIAPRB          = $DC01

;===============================================================================
; $E000-$FFFF  KERNAL ROM (8K) 


;===============================================================================

